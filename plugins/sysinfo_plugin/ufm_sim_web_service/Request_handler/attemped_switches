import aiohttp
import http
import requests
import time
from twisted.internet import defer
import logging
from enum import Enum
import json
from io import StringIO
import asyncio


class UFMRestAction(Enum):
    PUT = "PUT"
    GET = "GET"
    DELETE = "DELETE"
    PATCH = "PATCH"
    POST = "POST"

class XmlGwException(Exception):
    pass

class BodyReceiver(asyncio.Protocol):

    def __init__(self, on_con_lost,deferred, timeout=None, startTime=None,headers=None, code=None):
        self.transport = None
        self.on_con_lost = on_con_lost
        self.deferred = deferred
        self.receieve_data = StringIO()
        self.timeout = timeout
        self.startTime = startTime
        self.headers = headers
        self.code = code

    def connection_made(self, transport):
        self.transport = transport

    def data_received(self, data):
        if self.code and self.code not in(http.client.OK, http.client.FOUND):
            print(self.code)
            err = "Http Communication Error"
            exc = XmlGwException(err)
            self.deferred.errback(exc)
            raise exc
        if self.timeout:
            remainingTime = self.timeout - (time.time() - self.startTime)
            if remainingTime <= 0:
                # Fire errback and raise error, because fire errback
                # don't stop receiving data
                err = "Switch Communication Error"
                self.deferred.errback(defer.TimeoutError(err))
                raise defer.TimeoutError(err)
        print((self.headers,data.decode()))
        self.receieve_data.write(data.decode())

    def connection_lost(self, exc):
        # The socket has been closed
        self.on_con_lost.set_result(True)
        try:
            self.deferred.add_done_callback(self.receieve_data.getvalue())
        except defer.AlreadyCalledError:
            pass
    
    @staticmethod
    def receive(response, timeout=None, startTime=None):
        print(response)
        deferred = asyncio.Future()
        response.deliverBody(BodyReceiver(True,deferred, timeout, startTime,response.request.headers,
                                          response.code))
        return deferred


DEFAULT_REST_REQUEST_TIMEOUT=60

class AsyncCommands:
    def __init__(self, ip, commands,ac=None):
        self.commands = commands
        self.switch = ip
        self.restMsg = UFMRestMgr()
        if ac:
            self.ac = ac
        else: #########not in producation
            self.ac = ("admin",'admin')
        self.respond = []
        self.is_connected = False

    async def run_commands_one_after_anther(self,session):
        for command in self.commands:
            try:
                respond = await self.send_command(session,command,self.ac[0],self.ac[1])
                self.respond.append(respond if respond else None)
            except ValueError:
                logging.error("Client request of decoding respond Json payload has failed")
            except Exception as other_exception:
                logging.error(other_exception)

    async def run_commands_all_at_once(self,session):
        try:
            self.respond = await self.send_command(session,self.commands,self.ac[0],self.ac[1])
        except ValueError:
            logging.error("Client request of decoding respond Json payload has failed")
        except Exception as other_exception:
            logging.error(other_exception)

    def _get_request_body(self, commands, execution_type="async") ->json:
        return json.dumps({"execution_type": execution_type,
                           "commands": commands})

    def _get_json_url(self) -> str:
        return '/admin/launch?script=json'

    def get_respond(self) -> list:
        return self.respond

    async def send_command(self,session,command,username,password):
        #real_url = 'https' + '://{0}{1}'.format(self.switch, self._get_json_url())

        #resp = self.restMsg.post(self.switch,443,self.ac[0],self.ac[1],real_url,self._get_request_body(command),timeout=DEFAULT_REST_REQUEST_TIMEOUT)
        #resp = await send_rest_request()
        resp = await self.restMsg.post(session,self.switch,
                                self._get_json_url(),username,password,
                                self._get_request_body(command),timeout=DEFAULT_REST_REQUEST_TIMEOUT,content_type="application/json")
        return resp


class UFMRestMgr:
    def __init__(self,cookieJar=None):
        self.scheme = 'https'
        self.port = 443
        self.loginRespond = {}
        self.cookies = cookieJar
        self.respond = None

    def get_respond(self):
        return self.respond

    def _get_default_headers(self):
        return {'User-Agent': 'Mozilla/5.0'}

    def _get_login_url(self,ip):
        return '%s://%s:%s/admin/launch?script=rh&template=login&action=login' % (self.scheme, ip, self.port)

    def _get_request_url(self, ip,port,url) :
        return '%s://%s:%s/%s' % (self.scheme, ip, port, url.lstrip('/'))

    def _is_valid_cookies(self):
        try:
            cookie_jar = self.cookies.get('_cookieJar', [])
            for cookie in cookie_jar:
                if cookie.name == 'session':
                    return True
            return False
        except Exception:
            return False

    async def post(self,session, ip, url, username, password, data=None, content_type=None, timeout=DEFAULT_REST_REQUEST_TIMEOUT):
        if ip in self.loginRespond:
            return await self._post(url, timeout, time.time(), data, content_type)
        await self._login(session, timeout, ip, time.time(), username, password)
        result = await self._post(session,url=url,ip=ip,data=data,content_type=content_type,timeout=timeout,startTime=time.time())
        if result:
            self.respond = result
        return result
    
    async def _login(self, session, timeout, ip, startTime, username, password):
        if self.loginRespond.get(ip,None):
            return self.loginRespond.get(ip)
        if timeout:
            timeout = timeout - (time.time() - startTime)
            if timeout <= 0 :
                deferred = asyncio.Future()
                deferred.add_done_callback(TimeoutError('REST request timed out')) ##pretty sure it isnt right
                return deferred
        
        login_url = self._get_login_url(ip)
        headers = self._get_default_headers()
        #headers['Content-Type'] = 'application/x-www-form-urlencoded'
        headers['Content-Type'] = 'application/json'
        #postdata = urllib.parse.urlencode({'d_user_id':'user_id', 't_user_id':'string', 'c_user_id':'string', 'e_user_id':'true', 'f_user_id':username, 'f_password':password})
        postdata = json.dumps({'d_user_id':'user_id', 't_user_id':'string', 'c_user_id':'string', 'e_user_id':'true', 'f_user_id':username, 'f_password':password})
        result_json = await self.fetch_url(session,login_url,method="POST", headers=headers, postdata=postdata)
        self.loginRespond[ip] = result_json
        return result_json

    async def fetch_url(self, session:aiohttp.ClientSession, url:str, method:str='GET', headers=None, postdata=None):
        try:
            #print((method, url, headers, postdata))
            async with session.request(method, url, headers=headers, json=postdata,verify_ssl=False) as respond:
                async with respond:
                    assert respond.status == 200
                    result = await respond.text()
                    deferred.add_done_callback(BodyReceiver.receive, timeout, startTime)
                    return result
        except Exception as exep:
            print(exep)

    async def _post(self,session:aiohttp.ClientSession, ip:str, url:str, timeout:float, startTime, data=None, content_type=None):
        if timeout:
            timeout = timeout - (time.time() - startTime)
            if timeout <= 0 :
                deferred = asyncio.Future()
                deferred.add_done_callback(TimeoutError('REST request timed out'))
                return deferred
        headers = self._get_default_headers()
        if content_type :
            headers['Content-Type'] = content_type
        request_url = self._get_request_url(ip,self.port,url)
        result_json = await self.fetch_url(session, request_url, headers=headers, method='POST', postdata=data)
        return result_json

        
class request_Handler_async:
    def __init__(self,switches,commands,ac=None) -> None:
        self.switches=switches
        self.commands=commands
        self.respond = {}
        self.ready=False
        self.ac = ac
        
    async def post_all_command(self) -> dict:
        ##for each of the switches post a command and get a return form it
        #it was already checked that the all switches are responding to this and exists
        cookieJar = aiohttp.CookieJar()

        tasks = []
        async_commands = {}
        switch_respond = {}
        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(DEFAULT_REST_REQUEST_TIMEOUT),cookie_jar=cookieJar) as session:
            for switch in self.switches:
                async_commands[switch] = AsyncCommands(ip=switch, commands=self.commands,ac=self.ac)
                tasks.append(async_commands[switch].run_commands_one_after_anther(session))
            await asyncio.gather(*tasks)
        for key,value in async_commands.items():
            switch_respond[key] = value.get_respond()
        return switch_respond




    def _get_request_body(self, commands, execution_type="async") ->json:
        return json.dumps({"execution_type": execution_type,
                           "commands": commands})

    def _get_json_url(self) -> str:
        return '/admin/launch?script=json'

    def post_Rest(self,cb):
        restMng=RestMng.get_instance()
        switch = self.switches[0]
        deferred = restMng.post(switch, 443, self.ac[0], self.ac[1],
                          self._get_json_url(),self._get_request_body(self.commands),
                          content_type='application/x-www-form-urlencoded', timeout=60)
        deferred.addCallback(self._parse_async_json_repond, switch)
        deferred.addCallback(cb,self.respond)
        deferred.addErrback(self.eb,switch)
        return deferred

    def _parse_async_json_repond(self,response,switch):
        print((response,switch))
        self.respond[switch] = json.loads(response)['results']
        self.ready = True
        print(self.respond)

    def eb(self,respond,switch):
        self.ready=True
        self.respond[switch]=respond
        print(respond)

